# **Летняя школа Eltex по C**
## Бахарев Максим Александрович
# **Как использовать Makefile**
## Компиляция файлов
Для компиляции отдельного задания в корне проекта напишите без квадратных скобок `make t[N]`, где `N` - номер нужного задания
## Удаление исполняемых файлов
Для удаления исполняемых файлов после компиляции в отдельном задании напишите без квадратных скобок `make d[N]`, где `N` - номер задания
# **Текст заданий**
## Задание 1. Битовые операции.
1. Вывести двоичное представление целого положительного числа, используя битовые операции (число вводится с клавиатуры).
2. Вывести двоичное представление целого отрицательного числа, используя битовые операции (число вводится с клавиатуры).
3. Найти количество единиц в двоичном представлении целого положительного числа (число вводится с клавиатуры).
4. Поменять в целом положительном числе (типа int) значение третьего байта на введенное пользователем число (изначальное число также вводится с клавиатуры).
## Задание 2. Массивы.
1. Вывести квадратную матрицу по заданному N.
2. Вывести заданный массив размером N в обратном порядке.
3. Заполнить верхний треугольник матрицы 0, а нижний 1.
4. Заполнить матрицу числами от 1 до N^2 улиткой.
## Задание 3. Указатели.
1. Поменять в целом положительном числе (типа int) значение третьего байта на введенное пользователем число (изначальное число также вводится с клавиатуры) через указатель (не применяя битовые операции).
2. Поменять код в программе.
3. Напишите программу, в которой определите массив типа int (размер массива 10 элементов от 1 до 10). Используйте указатель для вывода элементов массива на консоль (применять можно только арифметику указателей, а не индексы).
4. Напишите программу, которая ищет введенной строке (с клавиатуры) введенную подстроку (с клавиатуры) и возвращает указатель на начало подстроки, если подстрока не найдена в указатель записывается NULL. В качестве срок использовать статические массивы.
## Задание 4. Структуры.
Написать программу абонентский справочник.
## Задание 5. Функции.
1. Переписать абонентский справочник с использованием функций.
2. Произвести анализ программы с помощью отладчика для выяснения длины массива для ввода пароля и адреса ветки условия проверки корректности ввода пароля, которая выполняется при условии совпадения паролей.
Ввести пароль (строку символов) таким образом, чтобы перезаписать адрес возврата на выясненный адрес (есть символы которые нельзя ввести с клавиатуры, поэтому можно использовать перенаправление ввода(<) при запуске программы).
## Задание 6. Динамическая память.
Переписать справочник абонентов (задание на структуры) со статического массива структур на двусвязный список структур. Вовремя запуска программы список пуст, при добавлении первого абонента выделяется память только под один элемент. По мере добавления абонентов список увеличивается по одному элементу.
Реализовать также следующие функции: удаление, поиск, завершение программы. По завершению программы память под список высвобождается.
## Задание 7. Статические библиотеки.
Написать калькулятор, выполняющий сложение, вычитание, умножение, деление с помощью статической библиотеки с этими функциями.
## Задание 8. Динамические библиотеки.
Переписать калькулятор, используя динамическую библиотеку вместо статической.
## Задание 9. Виртуальная файловая система.
1. Написать программу, которая создает файл с именем output.txt, записывает в него строку “String from file”, затем считывает ее из файла с конца и выводит на экран.
2. Реализовать файловый менеджер на подобии mc, с функционалом навигации по папкам и двумя панелями (переключение между панелями через Tab). Использовать для графики библиотеку ncurses.
## Задание 10. Управление процессами.
1. Реализовать программу, которая порождает процесс. Родительский процесс и дочерний выводят на экран свой pid, ppid. Затем родительский ждет завершения дочернего и выводит его статус завершения.
2. Реализовать программу, которая порождает процесс1 и процесс2, ждет завершения дочерних процессов. Процесс1 в свою очередь порождает процесс3 и процесс4 и ждет их завершения. Процесс2 порождает процесс5 и ждет его завершения. Все процессы выводят на экран свой pid, ppid.
3. Реализовать аналог командного интерпретатора bash. При запуске программы пользователю предлагается ввести имя программы и опции запуска программы. Программа порождает процесс и в нем выполняет введенную программу с заданными опциями, ждет завершения дочернего процесса.
Снова возвращается к вводу следующей программы. Выход из интерпретатора по команде exit.
## Задание 11. Потоки.
1. Написать программу с запуском пяти потоков, каждый со своим индексом, и выводит его на экран.
2. Написать программу с последовательным циклом инкрементации переменной, с помощью мьютексов и без них, чтобы увидеть конкуренцию.
3. Написать симуляцию жизни, используя параплельное программирование, то есть потоки. При запуске формирует массив из 5 int чисел, и рандомно заполняет каждый элемент массива в пределах 10 тысяч. Каждое число - это "магазин". Затем программа порождает три потока - "покупателей". При порождении "покупателя" у него есть потребность, рандомно в пределах 100 тысяч генерируется, то есть явно больше чем в "магазинах".
Поток пытается зайти в первый свободный "магазин". Зайти в "магазин" где уже есть "покупатель" нельзя, то есть он блокируется, в остальные "магазины" свободные можно. Покупатель забирает из магазина все товары, и уменьшает свою потребность. Засыпает на две секунды, потом опять ищет свободный магазин. Если в магазине товара больше чем потребность, забирает лишь то, что ему нужно, и на этом поток покупатель завершает свою работу.
Еще есть четвертый поток, так называемый "погрузчик", который также заходит в свободный магазин и добавляет туда по 5 тысяч продуктов. Засыпает на секунду, и ищет следующий магазин.
Каждый поток выводит о себе информацию, по типу "я покупатель, моя потребность такая, я зашел в этот магазин, моя потребность стала такой, заснул", а погрузчик - "я в таком магазине, там столько продуктов, я столько положил, заснул". При завершении потоков покупателей, основная программа завершает погрузчика и завершает себя. Лучше всего записывать это в лог, чтобы потом анализировать.
## Задание 12. Каналы.
1. Реализовать программу, которая создает неименованный канал и порождает процесс. Родительский процесс закрывает дескриптор для чтения из канала и записывает в канал строку “Hi!”, затем ожидает завершения дочернего процесса.
Дочерний процесс закрывает дескриптор для записи в канал, считывает строку из канала и выводит на экран.
2. Реализовать 2 программы, первая сервер, вторая клиент. Сервер создает именованный канал и открывает его только на запись, записывает строку “Hi!” и завершается.
Клиент открывает созданный канал сервером только на чтение, считывает строку из канала и выводит на экран. Удаляет канал.
3. Переписать командный интерпретатор из задания по процессам так, чтобы он поддерживал конструкции вида:
$ ls -la | grep a
## Задание 13. Очереди сообщений.
## Задание 14. Разделяемая память и семафоры.
## Задание 15. Сигналы.
1. Реализовать программу, которая переопределяет диспозицию сигнал SIGUSR1 с помощью вызова sigaction(), после чего уходит в бесконечный цикл ожидания. В функции диспозиции сигнала на экран выводится сообщение о получении сигнала. 
Также необходимо реализовать вторую программу, которая будет посылать первой программе сигнал SIGUSR1 через вызов kill(). Дополнительно научится посылать сигнал с помощью утилиты kill.
2. Реализовать программу, которая будет блокировать сигнал SIGINT с помощью вызова sigprocmask() и уходить в бесконечный цикл. Проверить работу программы с помощью второй программы из задачи 1 и утилиты kill.
3. Написать программу, в которой реализуется event-loop с помощью вызова sigwait(). При запуске программа блокирует сигнал SIGUSR1 и переходит в бесконечный цикл ожидания сигнала,
при получении сигнала на экран выводится сообщение о получении сигнала и осуществляется переход на следующую итерацию цикла. Проверить программу с помощью второй программы из задачи 1 и утилиты kill.
