# **Летняя школа Eltex по C**
## Бахарев Максим Александрович
# **Как использовать Makefile**
## Компиляция файлов
Для компиляции отдельного задания в корне проекта напишите без квадратных скобок `make t[N]`, где `N` - номер нужного задания (1-16 и final для выпускных заданий).
## Удаление исполняемых файлов
Для удаления исполняемых файлов после компиляции в отдельном задании напишите без квадратных скобок `make d[N]`, где `N` - номер задания.
# **Текст заданий**
## Задание 1. Битовые операции.
1. Вывести двоичное представление целого положительного числа, используя битовые операции (число вводится с клавиатуры).
2. Вывести двоичное представление целого отрицательного числа, используя битовые операции (число вводится с клавиатуры).
3. Найти количество единиц в двоичном представлении целого положительного числа (число вводится с клавиатуры).
4. Поменять в целом положительном числе (типа int) значение третьего байта на введенное пользователем число (изначальное число также вводится с клавиатуры).
## Задание 2. Массивы.
1. Вывести квадратную матрицу по заданному N.
2. Вывести заданный массив размером N в обратном порядке.
3. Заполнить верхний треугольник матрицы 0, а нижний 1.
4. Заполнить матрицу числами от 1 до N^2 улиткой.
## Задание 3. Указатели.
1. Поменять в целом положительном числе (типа int) значение третьего байта на введенное пользователем число (изначальное число также вводится с клавиатуры) через указатель (не применяя битовые операции).
2. Поменять код в программе.
3. Напишите программу, в которой определите массив типа int (размер массива 10 элементов от 1 до 10). Используйте указатель для вывода элементов массива на консоль (применять можно только арифметику указателей, а не индексы).
4. Напишите программу, которая ищет введенной строке (с клавиатуры) введенную подстроку (с клавиатуры) и возвращает указатель на начало подстроки, если подстрока не найдена в указатель записывается NULL. В качестве срок использовать статические массивы.
## Задание 4. Структуры.
Написать программу абонентский справочник.
## Задание 5. Функции.
1. Переписать абонентский справочник с использованием функций.
2. Произвести анализ программы с помощью отладчика для выяснения длины массива для ввода пароля и адреса ветки условия проверки корректности ввода пароля, которая выполняется при условии совпадения паролей.
Ввести пароль (строку символов) таким образом, чтобы перезаписать адрес возврата на выясненный адрес (есть символы которые нельзя ввести с клавиатуры, поэтому можно использовать перенаправление ввода(<) при запуске программы).
## Задание 6. Динамическая память.
Переписать справочник абонентов (задание на структуры) со статического массива структур на двусвязный список структур. Вовремя запуска программы список пуст, при добавлении первого абонента выделяется память только под один элемент. По мере добавления абонентов список увеличивается по одному элементу.
Реализовать также следующие функции: удаление, поиск, завершение программы. По завершению программы память под список высвобождается.
## Задание 7. Статические библиотеки.
Написать калькулятор, выполняющий сложение, вычитание, умножение, деление с помощью статической библиотеки с этими функциями.
## Задание 8. Динамические библиотеки.
Переписать калькулятор, используя динамическую библиотеку вместо статической.
## Задание 9. Виртуальная файловая система.
1. Написать программу, которая создает файл с именем output.txt, записывает в него строку “String from file”, затем считывает ее из файла с конца и выводит на экран.
2. Реализовать файловый менеджер на подобии mc, с функционалом навигации по папкам и двумя панелями (переключение между панелями через Tab). Использовать для графики библиотеку ncurses.
## Задание 10. Управление процессами.
1. Реализовать программу, которая порождает процесс. Родительский процесс и дочерний выводят на экран свой pid, ppid. Затем родительский ждет завершения дочернего и выводит его статус завершения.
2. Реализовать программу, которая порождает процесс1 и процесс2, ждет завершения дочерних процессов. Процесс1 в свою очередь порождает процесс3 и процесс4 и ждет их завершения. Процесс2 порождает процесс5 и ждет его завершения. Все процессы выводят на экран свой pid, ppid.
3. Реализовать аналог командного интерпретатора bash. При запуске программы пользователю предлагается ввести имя программы и опции запуска программы. Программа порождает процесс и в нем выполняет введенную программу с заданными опциями, ждет завершения дочернего процесса.
Снова возвращается к вводу следующей программы. Выход из интерпретатора по команде exit.
## Задание 11. Потоки.
1. Написать программу с запуском пяти потоков, каждый со своим индексом, и выводит его на экран.
2. Написать программу с последовательным циклом инкрементации переменной, с помощью мьютексов и без них, чтобы увидеть конкуренцию.
3. Написать симуляцию жизни, используя параплельное программирование, то есть потоки. При запуске формирует массив из 5 int чисел, и рандомно заполняет каждый элемент массива в пределах 10 тысяч. Каждое число - это "магазин". Затем программа порождает три потока - "покупателей". При порождении "покупателя" у него есть потребность, рандомно в пределах 100 тысяч генерируется, то есть явно больше чем в "магазинах".
Поток пытается зайти в первый свободный "магазин". Зайти в "магазин" где уже есть "покупатель" нельзя, то есть он блокируется, в остальные "магазины" свободные можно. Покупатель забирает из магазина все товары, и уменьшает свою потребность. Засыпает на две секунды, потом опять ищет свободный магазин. Если в магазине товара больше чем потребность, забирает лишь то, что ему нужно, и на этом поток покупатель завершает свою работу.
Еще есть четвертый поток, так называемый "погрузчик", который также заходит в свободный магазин и добавляет туда по 5 тысяч продуктов. Засыпает на секунду, и ищет следующий магазин.
Каждый поток выводит о себе информацию, по типу "я покупатель, моя потребность такая, я зашел в этот магазин, моя потребность стала такой, заснул", а погрузчик - "я в таком магазине, там столько продуктов, я столько положил, заснул". При завершении потоков покупателей, основная программа завершает погрузчика и завершает себя. Лучше всего записывать это в лог, чтобы потом анализировать.
## Задание 12. Каналы.
1. Реализовать программу, которая создает неименованный канал и порождает процесс. Родительский процесс закрывает дескриптор для чтения из канала и записывает в канал строку “Hi!”, затем ожидает завершения дочернего процесса.
Дочерний процесс закрывает дескриптор для записи в канал, считывает строку из канала и выводит на экран.
2. Реализовать 2 программы, первая сервер, вторая клиент. Сервер создает именованный канал и открывает его только на запись, записывает строку “Hi!” и завершается.
Клиент открывает созданный канал сервером только на чтение, считывает строку из канала и выводит на экран. Удаляет канал.
3. Переписать командный интерпретатор из задания по процессам так, чтобы он поддерживал конструкции вида:
$ ls -la | grep a
## Задание 13. Очереди сообщений.
1. Реализовать 2 программы, первая сервер, вторая клиент. Сервер создает очередь сообщений и записывает сообщение виде строки “Hi!”, ждет ответа от клиента и выводит на экран, удаляет очередь. Клиент подключается к очереди считывает сообщение от сервера, выводит на экран, отвечает серверу сообщением виде строки “Hello!”. Сделать это как для POSIX, так и для SYSTEM V стандартов.
2. Написать 2 программы, первая сервер, вторая клиент. Сервер создает очередь сообщений для реализации чата с общей комнатой (если необходимо, то можно и больше очередей создать) и его задача уведомлять клиентов о появлении новых участников, о новых сообщениях.
Клиент подключается к очереди, созданной сервером, сообщает ему свое имя и получает в ответ все сообщения в комнате. Далее может отправлять сообщения в общий чат. Получение служебных сообщений от сервера (имена новых клиентов, сообщения от других пользователей) и отправка сообщений в чат лучше реализовать в разных потоках.
Интерфейс клиента реализуем с помощью библиотеки ncurses.
## Задание 14. Разделяемая память и семафоры.
Как задание 13, только работа уже с сегментами разделяемой памяти.
## Задание 15. Сигналы.
1. Реализовать программу, которая переопределяет диспозицию сигнал SIGUSR1 с помощью вызова sigaction(), после чего уходит в бесконечный цикл ожидания. В функции диспозиции сигнала на экран выводится сообщение о получении сигнала. 
Также необходимо реализовать вторую программу, которая будет посылать первой программе сигнал SIGUSR1 через вызов kill(). Дополнительно научится посылать сигнал с помощью утилиты kill.
2. Реализовать программу, которая будет блокировать сигнал SIGINT с помощью вызова sigprocmask() и уходить в бесконечный цикл. Проверить работу программы с помощью второй программы из задачи 1 и утилиты kill.
3. Написать программу, в которой реализуется event-loop с помощью вызова sigwait(). При запуске программа блокирует сигнал SIGUSR1 и переходит в бесконечный цикл ожидания сигнала,
при получении сигнала на экран выводится сообщение о получении сигнала и осуществляется переход на следующую итерацию цикла. Проверить программу с помощью второй программы из задачи 1 и утилиты kill.
## Задание 16. Сокеты.
1. Написать клиента, который будет передавать серверу строку «hello!» и ждать ответа от сервера, при получении выводить ответ сервера. Также нужно написать сервер, который получит от клиента строку, выведет ее и отправит в ответ строку «hi!». Это нужно сделать для следующих вариантов сокетов:
1) AF_LOCAL, SOCK_DGRAM
2) AF_LOCAL, SOCK_STREAM
3) AF_INET, SOCK_DGRAM
4) AF_INET, SOCK_STREAM.
2. Написать клиента (протокол неважен), который будет запрашивать текущее время у сервера. Так же необходимо реализовать следующие сервера:
1) Слушающий сервер создает для обслуживания каждого клиента поток/процесс обслуживания. По завершению обслуживая поток/процесс завершается.
2) Во время запуска сервера создается пул потоков/процессов обслуживания.
При получении  запроса от клиента, слушающий сервер выбирает из пула свободный поток/процесс и переключает клиента на него. По завершению обслуживания клиента, обслуживающий сервер уведомляет слушающий сервер о том, что он освободился и готов обслужить следующего клиента.
3) Реализовать шаблон потребитель/производитель. Слушающий сервер создает во время запуска пул потоков/процессов обслуживания, а также создает очередь запросов (очередь можно реализовать самому или использовать готовые варианты, например очереди сообщений).
При поступлении запроса от клиента, слушающий сервер ставит заявку с адресом клиента в очередь. Свободные обслуживающие потоки/процессы следят за очередью и когда появляется заявка берут ее в обработку и отвечают клиенту.
4) Реализовать мультипротокольный  сервер. Сервер должен в одном потоке обслуживать как tcp, так и udp клиентов. Использовать для реализации сервера функции мультиплексирования select/poll/epoll.
3. Реализовать сервер и клиент для следующих видов передачи данных (передаваться будет набор произвольных символов):
1) broadcast
2) multicast
4. raw сокеты.
Реализовать сервер с использованием udp протокола(обычный сокет). Сервер ждет строку от клиента (при получении выводит на экран), при получении строки модифицирует произвольный символ и полученную строку отправляет клиенту (предварительно выводит модифицированную строку на экран). Так же необходимо реализовать следующие клиенты (udp, raw сокеты):
1) Клиент отправляет строку серверу и к ней добавляет udp заголовок.
2) К первому заданию добавляется заголовок ip.
3) Ко второму заданию добавляется заголовок канального уровня. 
Клиент ждет ответа от сервера (фильтруя ненужные пакеты) и при получении ответа выводит строку из ответа сервера.
## Задание 17. Ядро Linux.
1. Собрать ядро Linux для x86_64, постараться выключить все лишние опции. Установить и проверить работоспособность. В качестве ответа прислать документ с командами сборки и установки ядра, скриншоты подтверждающие работоспособность системы и запуск ядра.
2. Собрать ядро под архитектуру arm и запустить в qemu, для проверки работоспособности. Отчет такой же как и в первом задании.
## Задание 18. Корневая файловая система.
1. Собрать корневую файловую систему состоящую из одного процесса init, который выводит строку “Hello” и засыпает на 15 секунд. Проверить работоспособность также в qemu.
2. Собрать корневую файловую систему на основе busybox и запустить в qemu с init процессом в виде командного интерпретатора /bin/ash.
В качестве отчета подготовить документ со всеми командами по сборке корневой файловой системы, процесса init, запуску qemu, а также скриншоты системы при запуске в qemu всех двух вариантов.
## Задание 19. Кросс-компиляция. (не до конца)
Собрать пакет openssh и все библиотеки от которых он зависит под архитектуру arm. Собранный пакет добавить в корневую файловую систему из предыдущего задания, запустить в qemu и проверить работоспособность.
В качестве отчета подготовить документ с командами по сборке библиотек и самого пакета, привести также команды по добавлению пакета и библиотек в корневую файловую систему и добавить скриншоты работы утилиты ssh в qemu.
## Выпускные задания
1. raw sockets + САОД + signals
Написать echo-client и echo-server на raw сокетах. Сервер должен отвечать клиенту то же самое сообщение + порядковый номер сообщения от этого клиента. Протокол сообщения - UDP.

Например:
Клиент 1 посылает на сервер сообщение “WAAAAAAAGH”
Сервер отвечает клиенту 1 “WAAAAAAAGH 1”
Клиент 1 посылает серверу сообщение “ping”
Сервер отвечает клиенту 1 “ping 2”
Клиент 2 посылает серверу сообщение “ping”
Сервер отвечает клиенту 2 “ping 1”
Клиент 1 посылает на сервер сообщение “WAAAAAAAGH”
Сервер отвечает клиенту 1 “WAAAAAAAGH 3”

При штатном выключении клиент должен посылать серверу сообщение о закрытии, после получения этого сообщения сервер должен сбросить связанные с данным клиентом счетчики и при последующем подключении клиента с тем же ip:port, начинать отсчет с 1.

2. fork + poll/epoll/select + timers + IPC
Управление такси.

Есть опорный пункт - исходное приложение. Запускается один раз и привязано к терминалу, имеет CLI.

В CLI должны быть команды create_driver, send_task <pid> <task_timer>, get_status <pid>, get_drivers.

create_driver создает новый процесс (driver), который ожидает команд от CLI, pid процесса будет использоваться  для обращения к этому driver.

send_task <pid> <task_timer> создаст задачу для driver номер <pid> и займет его на <task_timer> секунд. Если попытаться обратиться к этому driver во время выполнения задания с помощью send_task, то driver должен послать ошибку Busy <task_timer>. По истечению <task_timer> секунд driver меняет свое состояние на Available.

get_status <pid> показывает статус driver с номером <pid>. Может быть Busy <task_timer> либо Available.

get_drivers показывает статусы и pid всех drivers запущенных из этого инстанса CLI.
